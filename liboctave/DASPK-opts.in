CLASS = "DASPK"

INCLUDE = "DAE.h"

OPTION
  NAME = "absolute tolerance"
  TYPE = "Array<double>"
  SET_ARG_TYPE = "const $TYPE&"
  INIT_BODY
    $OPTVAR.resize (1);
    $OPTVAR(0) = ::sqrt (DBL_EPSILON);
  END_INIT_BODY
  SET_CODE
    void set_$OPT (double val)
      {
        $OPTVAR.resize (1);
        $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
        reset = true;
      }

    void set_$OPT (const $TYPE& val)
      { $OPTVAR = val; reset = true; }
  END_SET_CODE
END_OPTION

OPTION
  NAME = "relative tolerance"
  TYPE = "Array<double>"
  SET_ARG_TYPE = "const $TYPE&"
  INIT_BODY
    $OPTVAR.resize (1);
    $OPTVAR(0) = ::sqrt (DBL_EPSILON);
  END_INIT_BODY
  SET_CODE
    void set_$OPT (double val)
      {
        $OPTVAR.resize (1);
        $OPTVAR(0) = (val > 0.0) ? val : ::sqrt (DBL_EPSILON);
        reset = true;
      }

    void set_$OPT (const $TYPE& val)
      { $OPTVAR = val; reset = true; }
  END_SET_CODE
END_OPTION

OPTION
  NAME = "compute consistent initial condition"
  TYPE = "int"
  INIT_VALUE = "0"
  SET_EXPR = "val"
END_OPTION

OPTION
  NAME = "algebraic variables"
  TYPE = "Array<int>"
  SET_ARG_TYPE = const $TYPE&
  INIT_BODY
    $OPTVAR.resize (1);
    $OPTVAR(0) = 0;
  END_INIT_BODY
  SET_CODE
    void set_$OPT (int val)
      {
        $OPTVAR.resize (1);
        $OPTVAR(0) = val;
        reset = true;
      }

    void set_$OPT (const $TYPE& val)
      { $OPTVAR = val; reset = true; }
  END_SET_CODE
END_OPTION

OPTION
  NAME = "enforce inequality constraints"
  TYPE = "int"
  INIT_VALUE = "0"
  SET_EXPR = "val"
END_OPTION

OPTION
  NAME = "inequality constraint types"
  TYPE = "Array<int>"
  SET_ARG_TYPE = const $TYPE&
  INIT_BODY
    $OPTVAR.resize (1);
    $OPTVAR(0) = 0;
  END_INIT_BODY
  SET_CODE
    void set_$OPT (int val)
      {
        $OPTVAR.resize (1);
        $OPTVAR(0) = val;
        reset = true;
      }

    void set_$OPT (const $TYPE& val)
      { $OPTVAR = val; reset = true; }
  END_SET_CODE
END_OPTION

OPTION
  NAME = "exclude algebraic variables from error test"
  TYPE = "int"
  INIT_VALUE = "0"
  SET_EXPR = "val"
END_OPTION

OPTION
  NAME = "use initial condition heuristics"
  TYPE = "int"
  INIT_VALUE = "0"
  SET_EXPR = "val"
END_OPTION

OPTION
  NAME = "initial condition heuristics"
  TYPE = "Array<double>"
  SET_ARG_TYPE = "const $TYPE&"
  INIT_BODY
    $OPTVAR.resize (6, 0.0);
    $OPTVAR(0) = 5.0;
    $OPTVAR(1) = 6.0;
    $OPTVAR(2) = 5.0;
    $OPTVAR(3) = 0.0;
    $OPTVAR(4) = ::pow (DBL_EPSILON, 2.0/3.0);
    $OPTVAR(5) = 0.01;
  END_INIT_BODY
  SET_EXPR = "val"
END_OPTION

OPTION
  NAME = "initial step size"
  TYPE = "double"
  INIT_VALUE = "-1.0"
  SET_EXPR = "(val >= 0.0) ? val : -1.0"
END_OPTION

OPTION
  NAME = "maximum order"
  TYPE = "int"
  INIT_VALUE = "-1"
  SET_EXPR = "val"
END_OPTION

OPTION
  NAME = "maximum step size"
  TYPE = "double"
  INIT_VALUE = "-1.0"
  SET_EXPR = "(val >= 0.0) ? val : -1.0"
END_OPTION

OPTION
  NAME = "print initial condition info"
  TYPE = "int"
  INIT_VALUE = "0"
  SET_EXPR = "val"
END_OPTION
